import random as rd
import networkx as nx


def create_hybrid_network(n_nodes: int, degree: int, p_preferential_attachment: float):
    """Returns a directed network generated by a combination of preferential attachment
    and uniform attachment. Note: while each node has a fixed out-degree, the in-degrees
    will have a scale-free distribution.

    Args:
    - n_nodes (int): number of nodes
    - degree (int): out_degree
    - p_preferential_attachment (float): probability of preferential attachment
    """
    # Create initial network
    network = nx.DiGraph()
    network.add_nodes_from(range(n_nodes))
    for node in network.nodes:
        potential_targets = list(network.nodes).copy()
        potential_targets.remove(node)
        targets = rd.sample(potential_targets, degree)
        edges_from_node = [(node, target) for target in targets]
        network.add_edges_from(edges_from_node)

    # Preferential rewiring
    network_rewired = rewire_network(network, p_preferential_attachment)
    return network_rewired


def rewire_network(network: nx.DiGraph, p_preferential_attachment: float):
    # Initialize network and nodes
    net = nx.DiGraph()
    net.add_nodes_from(network.nodes)

    # Hybrid attachment
    edges_to_do = list(network.edges()).copy()
    rd.shuffle(edges_to_do)
    for source, _ in edges_to_do:
        potential_targets = [
            node for node in net.nodes if node not in net[source] and node != source
        ]
        if not potential_targets:
            break

        if rd.random() < p_preferential_attachment:
            # Preferential attachment
            list_of_tuples = list(
                net.in_degree(potential_targets)
            )  # list of tuples of the form (node, in_degree of node)
            potential_targets_in_degrees = list(
                map(lambda tuple_item: tuple_item[1], list_of_tuples)
            )
            if all(w == 0 for w in potential_targets_in_degrees):
                # catches the case where all weights are zero
                target_new = rd.choice(potential_targets)
            else:
                target_new = rd.choices(
                    population=potential_targets,
                    weights=potential_targets_in_degrees,
                )[0]
                # Note on [0]: rd.choices produces a list
        else:
            # Random attachment
            target_new = rd.choice(potential_targets)
        net.add_edge(source, target_new)
    return net




# Ignacios proposed network randomization:

def randomized_barabasi_albert_graph(n_nodes,n_edges_to_add,randomization_probability):
    G = nx.barabasi_albert_graph(n_nodes, n_edges_to_add)
    return randomize_network_v2(G, randomization_probability)


def randomize_network_v2(G, randomization_probability):
    
    edges = list(G.edges()).copy()
    rd.shuffle(edges)
    edges_set = set(edges)
    nodes = list(G.nodes()).copy()
    new_edges_set = set()
    to_remove_set = set()
    for old_edge in edges:
        if rd.random() < randomization_probability:  # p probability to rewire an edge
            to_remove_set.add(old_edge)
            new_edge = (rd.choice(nodes),rd.choice(nodes))
            while (new_edge in new_edges_set) or (new_edge[0] == new_edge[1]):
                new_edge = (rd.choice(nodes),rd.choice(nodes))
            new_edges_set.add(new_edge)
    # Update the graph with new edges
    G_new = G.copy() # not doing this because it takes up memory
    G_new.remove_edges_from(list(to_remove_set))
    G_new.add_edges_from(list(new_edges_set))
    return G_new